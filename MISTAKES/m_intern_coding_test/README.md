# M사 인턴 코딩테스트

CodeSignal이란 플랫폼에서 1시간5분동안 4문제 풀었음.

1번 5분걸렸는데 `vector.resize`랑 `vector.reserve` 헷갈려서 결과 배열에 앞부분 비어서 나왔음 (`vector.resize` 하면 빈 공간 잡아버리는데 거기다가 이어서 `push_back` 해버림)

---

4번은 보지도 못했고

---

2,3 에서 페이스 말려서 50분 쓴거같다.

2번은 배열 왼쪽에서부터 정수 하나씩 골라서 음수 안될때까지 오른쪽으로 피벗 옮기면서 하나씩 빼는 단순 구현문제.

```c
3 3 5 2 1   // 3
0 0 2 2 1   // 2
0 0 0 0 1   // 1
0 0 0 0 0   // 전부 0이므로 종료

// 3 + 2 + 1
```

매번 0부터 시작하는 피봇 갖는 loop에서 돌면서 배열값 빼주고 전체 0이면 종료시켰는데 edge케이스 못봤는지 ac못함 병신.

비슷한문제 찾는중이고 생각해보니 o(N)에도 풀수있을꺼같다. 자살말린다

---

3번은 문자열 파싱.  
`@`를 기점으로 아이디 주어지면 한 메세지당 id 중복 없게 카운팅하는거. (hashMap) 하나의 메세지에서 중복 카운팅 안하고 있다가 생각나서 unordered set 쓰려니까 시간종료.

`@all`같은 경우는 전체 태그라 모두 증가시켜줌. 이거 따로 `if(parsedId == all)` 해서 처리하는 부분에서 loop아예 탈출 시키던가 pivot값을 옮기던가 했었어야 했는데 둘다 안해서 **하나의 메세지 안에서 all 키워드 계속 찾으면서 무한루프 발생**

IDE따로 사용가능했으면 콘솔 찍으면서 잡았을텐데 맨날 좋은 상황만 주어지는건 아니니까...

그리고 C++에서 substr할 때

### string.substr(시작인덱스, 끝인덱스) 가 아니라

### string.substr(시작인덱스, 빼올문자개수)

이다.  
string.find(char, pivot) 해서 시작지점, 끝지점 인덱스 가져왔으면  
string.substr(st, end-st) 해야지 정상적으로 되지 string.substr(st, end) 해버리면 end 인덱스가 크면 문자 이상하게 길게 빼버린다.

---

단순 구현문제들인데 문자열만 나오면 페이스 말리고 원래 실력 반의반도 못보여줘서 속상하다. 완탐이고 dfs고 bfs고 다익스트라고 나발이고 저딴거 할게 아니라 문자열, 단순구현부터 제대로 잡아야 할 듯 하다.
