# 나무 자르기

[https://www.acmicpc.net/problem/2805](https://www.acmicpc.net/problem/2805)

반성해야할 부분

1. log 와 시간복잡도 이해
2. 자료형 오버플로우 여부 확인
3. 문제 조건에 의한 이분탐색 종료조건 설정

### 1. log와 시간복잡도

나무의 개수 N: [1, 1'000'000]  
나무의 길이 M: [1, 2'000'000'000]  
필요한 길이 합: [0, 1'000'000'000]

매 탐색 시 나무의 개수 만큼을 순회 `O(N)` 나무의 길이를 이분탐색 `O(log M)` ==> `O(N + logM)` 인데 시간제한이 1초라 최악이 1억을 넘어가면 안됨.  
**log 1'000'000'000** 는 10'000 이 아니라 28정도이다... 정신 차리다.

<br/>   
   
### 2. 자료형 오버플로우   
   
매 탐색 시 나무의 개수만큼 순회하며 잘라갈 수 있는 나무의 길이를 합산하는데, 최악의 경우 _나무의 최대길이_ * _최대 나무의 개수_ = *2'000'000'000'000'000* 로 변수 sum은 int의 최대값을 훌쩍 넘는다.   
sum과 관련된 변수, 함수 모두 long long   
   
<br/>

### 3. 이분탐색 종료 조건

이분탐색의 종료조건을 정해줄 때 **목표값에 도달** 하거나 **left나 right가 범위를 벗어날 때** 가 있다.

```
나무의 높이의 합은 항상 M보다 크거나 같기 때문에...
```

다음과 같은 문제 조건에 따라 나무의 길이가 부족해 이분탐색의 최좌측으로 빠지는 경우는 없으므로 == **탐색 범위를 벗어나 종료한다면 left 피벗이 최대 범위를 벗어난 경우** 이므로

```cpp
if(left > right) {
    return right;
}
```

와 같이 정상범위에 있는 right 를 리턴해준다.
